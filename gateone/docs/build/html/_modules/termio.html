

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>termio &mdash; Gate One 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="top" title="Gate One 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Gate One Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for termio</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c">#       Copyright 2011 Liftoff Software Corporation (http://liftoffsoftware.com)</span>
<span class="c">#</span>
<span class="c"># NOTE:  Commercial licenses for this software are available!</span>
<span class="c">#</span>

<span class="c"># TODO: See if we can spin off termio.py into its own little program that sits between Gate One and ssh_connect.py.  That way we can take advantage of multiple cores/processors (for terminal-to-HTML processing).  There&#39;s no reason why we can&#39;t write something that does what dtach does.  Just need to redirect the fd of self.cmd to a unix domain socket and os.setsid() somewhere after forking (twice maybe?).</span>
<span class="c"># TODO: Make the environment variables used before launching self.cmd configurable</span>

<span class="c"># Meta</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&#39;0.9&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s">&quot;AGPLv3 or Proprietary (see LICENSE.txt)&quot;</span>
<span class="n">__version_info__</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s">&#39;Dan McDougall &lt;daniel.mcdougall@liftoffsoftware.com&gt;&#39;</span>

<span class="n">__doc__</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">About termio</span>
<span class="s">============</span>
<span class="s">This module provides a Multiplex class that can perform the following:</span>

<span class="s"> * Fork a child process that opens a given terminal program.</span>
<span class="s"> * Read and write data to and from the child process.</span>
<span class="s"> * Log the output of the child process to a file and/or syslog.</span>

<span class="s">The Multiplex class is meant to be used in conjunction with a running Tornado</span>
<span class="s">IOLoop instance.  It can be instantiated from within your Tornado application</span>
<span class="s">like so::</span>

<span class="s">    multiplexer = termio.Multiplex(</span>
<span class="s">        &#39;nethack&#39;,</span>
<span class="s">        log_path=&#39;/var/log/myapp&#39;,</span>
<span class="s">        user=&#39;bsmith@CORP&#39;,</span>
<span class="s">        term_id=1,</span>
<span class="s">        syslog=True</span>
<span class="s">    )</span>

<span class="s">Then *multiplexer* can create and launch a new controlling terminal (tty)</span>
<span class="s">running the given command (e.g. &#39;nethack&#39;)::</span>

<span class="s">    env = {</span>
<span class="s">        &#39;PATH&#39;: os.environ[&#39;PATH&#39;],</span>
<span class="s">        &#39;MYVAR&#39;: &#39;foo&#39;</span>
<span class="s">    }</span>
<span class="s">    fd = multiplexer.spawn(80, 24, env=env)</span>
<span class="s">    # The fd is returned from spawn() in case you want more low-level control.</span>

<span class="s">Input and output from the controlled program is asynchronous and gets handled</span>
<span class="s">via IOLoop.  It will automatically write all output from the terminal program to</span>
<span class="s">an instance of self.terminal_emulator (which defaults to Gate One&#39;s</span>
<span class="s">terminal.Terminal).  So if you want to perform an action whenever the running</span>
<span class="s">terminal application has output (like, say, sending a message to a client)</span>
<span class="s">you&#39;ll need to attach a callback::</span>

<span class="s">    def screen_update():</span>
<span class="s">        &#39;Called when new output is ready to send to the client&#39;</span>
<span class="s">        output = multiplexer.dumplines()</span>
<span class="s">        socket_or_something.write(output)</span>
<span class="s">    multiplexer.callbacks[multiplexer.CALLBACK_UPDATE] = screen_update</span>

<span class="s">In this example, screen_update() will write() the output of</span>
<span class="s">multiplexer.dumplines() to *socket_or_something* whenever the terminal program</span>
<span class="s">has some sort of output.  You can also make calls directly to the terminal</span>
<span class="s">emulator (if you&#39;re using a custom one)::</span>

<span class="s">    def screen_update():</span>
<span class="s">        output = multiplexer.term.my_custom_func()</span>
<span class="s">        whatever.write(output)</span>

<span class="s">Writing characters to the controlled terminal application is pretty</span>
<span class="s">straightforward::</span>

<span class="s">    multiplexer.write(&#39;some text&#39;)</span>

<span class="s">Typically you&#39;d pass in keystrokes or commands from your application to the</span>
<span class="s">underlying program this way and the screen/terminal emulator would get updated</span>
<span class="s">automatically.  If using Gate One&#39;s Terminal() you can also attach callbacks</span>
<span class="s">to perform further actions when more specific situations are encountered (e.g.</span>
<span class="s">when the window title is set via that respective escape sequence)::</span>

<span class="s">    def set_title():</span>
<span class="s">        &#39;Hypothetical title-setting function&#39;</span>
<span class="s">        print(&quot;Window title was just set to: </span><span class="si">%s</span><span class="s">&quot; % multiplexer.term.title)</span>
<span class="s">    multiplexer.term.callbacks[multiplexer.CALLBACK_TITLE] = set_title</span>

<span class="s">Module Functions and Classes</span>
<span class="s">============================</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="c"># Stdlib imports</span>
<span class="kn">import</span> <span class="nn">signal</span><span class="o">,</span> <span class="nn">threading</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">struct</span><span class="o">,</span> <span class="nn">io</span><span class="o">,</span> <span class="nn">gzip</span><span class="o">,</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span><span class="p">,</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="c"># Import our own stuff</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">get_translation</span><span class="p">,</span> <span class="n">human_readable_bytes</span><span class="p">,</span> <span class="n">noop</span><span class="p">,</span> <span class="n">which</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">get_or_update_metadata</span><span class="p">,</span> <span class="n">json_encode</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">get_translation</span><span class="p">()</span>

<span class="c"># Globals</span>
<span class="n">SEPARATOR</span> <span class="o">=</span> <span class="s">u&quot;</span><span class="se">\U000f0f0f</span><span class="s">&quot;</span> <span class="c"># The character used to separate frames in the log</span>
<span class="c"># NOTE: That unicode character was carefully selected from only the finest</span>
<span class="c"># of the PUA.  I hereby dub thee, &quot;U+F0F0F0, The Separator.&quot;</span>
<span class="n">CALLBACK_THREAD</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Used by add_callback()</span>
<span class="n">POSIX</span> <span class="o">=</span> <span class="s">&#39;posix&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span>

<span class="c"># Helper functions</span>
<div class="viewcode-block" id="debug_expect"><a class="viewcode-back" href="../Developer/termio.html#termio.debug_expect">[docs]</a><span class="k">def</span> <span class="nf">debug_expect</span><span class="p">(</span><span class="n">m_instance</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method is used by :py:meth:`BaseMultiplex.expect` if :py:attr:`BaseMultiplex.debug` is True.  It</span>
<span class="sd">    facilitates easy debugging of regular expressions.  It will print out</span>
<span class="sd">    precisely what was matched and where.</span>

<span class="sd">    .. note::  This function only works with post-process patterns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> was matched...&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">m_instance</span><span class="o">.</span><span class="n">dump</span><span class="p">():</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
        <span class="n">match_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match_obj</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s">&quot;---&gt;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s">&quot;    </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<span class="c"># Exceptions</span></div>
<div class="viewcode-block" id="Timeout"><a class="viewcode-back" href="../Developer/termio.html#termio.Timeout">[docs]</a><span class="k">class</span> <span class="nc">Timeout</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used by :py:meth:`BaseMultiplex.expect` and :py:meth:`BaseMultiplex.await`;</span>
<span class="sd">    called when a timeout is reached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c"># Classes</span></div>
<div class="viewcode-block" id="Pattern"><a class="viewcode-back" href="../Developer/termio.html#termio.Pattern">[docs]</a><span class="k">class</span> <span class="nc">Pattern</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used by :py:meth:`BaseMultiplex.expect`, an object to store patterns</span>
<span class="sd">    (regular expressions) and their associated properties.</span>

<span class="sd">    .. note:: The variable *m_instance* is used below to mean the current instance of BaseMultiplex (or a subclass thereof).</span>

<span class="sd">    .. py:attribute:: pattern</span>

<span class="sd">        A regular expression or iterable of regular expressions that will be</span>
<span class="sd">        checked against the output stream.</span>

<span class="sd">    .. py:attribute:: callback</span>

<span class="sd">        A function that will be called when the pattern is matched.  Callbacks</span>
<span class="sd">        are called like so:</span>

<span class="sd">            &gt;&gt;&gt; callback(m_instance, matched_string)</span>

<span class="sd">    .. py:attribute:: optional</span>

<span class="sd">        Indicates that this pattern is optional.  Meaning that it isn&#39;t required</span>
<span class="sd">        to match before the next pattern in :py:attr:`BaseMultiplex._patterns`</span>
<span class="sd">        is checked.</span>

<span class="sd">    .. py:attribute:: sticky</span>

<span class="sd">        Indicates that the pattern will not time out and won&#39;t be automatically</span>
<span class="sd">        removed from self._patterns when it is matched.</span>

<span class="sd">    .. py:attribute:: errorback</span>

<span class="sd">        A function to call in the event of a timeout or if an exception is</span>
<span class="sd">        encountered.  Errorback functions are called like so:</span>

<span class="sd">            &gt;&gt;&gt; errorback(m_instance)</span>

<span class="sd">    .. py:attribute:: preprocess</span>

<span class="sd">        Indicates that this pattern is to be checked against the incoming stream</span>
<span class="sd">        before it is processed by the terminal emulator.  Useful if you need to</span>
<span class="sd">        match non-printable characters like control codes and escape sequences.</span>

<span class="sd">    .. py:attribute:: timeout</span>

<span class="sd">        A :py:obj:`datetime.timedelta` object indicating how long we should wait</span>
<span class="sd">        before calling :py:meth:`errorback`.</span>

<span class="sd">    .. py:attribute:: created</span>

<span class="sd">        A :py:obj:`datetime.datetime` object that gets set when the Pattern is</span>
<span class="sd">        instantiated by :py:meth:`BaseMultiplex.expect`.  It is used to</span>
<span class="sd">        determine if and when a timeout has been reached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">sticky</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">errorback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">preprocess</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorback</span> <span class="o">=</span> <span class="n">errorback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optional</span> <span class="o">=</span> <span class="n">optional</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sticky</span> <span class="o">=</span> <span class="n">sticky</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">preprocess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex">[docs]</a><span class="k">class</span> <span class="nc">BaseMultiplex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class that all Multiplex types will inherit from.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CALLBACK_UPDATE</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Screen update</span>
    <span class="n">CALLBACK_EXIT</span> <span class="o">=</span> <span class="mi">2</span>   <span class="c"># When the underlying program exits</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">cmd</span><span class="p">,</span>
            <span class="n">terminal_emulator</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="c"># Defaults to Gate One&#39;s terminal.Terminal</span>
            <span class="n">log_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">user</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="c"># Only used by log output (to differentiate who&#39;s who)</span>
            <span class="n">term_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="c"># Also only for syslog output for the same reason</span>
            <span class="n">syslog</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">syslog_host</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">syslog_facility</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">terminal_emulator</span><span class="p">:</span>
            <span class="c"># Why do this?  So you could use/write your own specialty emulator.</span>
            <span class="c"># Whatever you use it just has to accept &#39;rows&#39; and &#39;cols&#39; as</span>
            <span class="c"># keyword arguments in __init__()</span>
            <span class="kn">from</span> <span class="nn">terminal</span> <span class="kn">import</span> <span class="n">Terminal</span> <span class="c"># Dynamic import to cut down on waste</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span> <span class="o">=</span> <span class="n">Terminal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span> <span class="o">=</span> <span class="n">terminal_emulator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span> <span class="o">=</span> <span class="n">log_path</span> <span class="c"># Logs of the terminal output wind up here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syslog</span> <span class="o">=</span> <span class="n">syslog</span> <span class="c"># See &quot;if self.syslog:&quot; below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">80</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c"># Means &quot;no pid yet&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="s">&quot;Never&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout_thread</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Setup our callbacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">{</span> <span class="c"># Defaults do nothing which saves some conditionals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span><span class="p">:</span> <span class="p">{},</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_EXIT</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>
        <span class="c"># Configure syslog logging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term_id</span> <span class="o">=</span> <span class="n">term_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog_host</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">syslog</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                    <span class="s">&quot;The syslog module is required to log terminal sessions to &quot;</span>
                    <span class="s">&quot;syslog if no syslog_host is set.  The syslog module is not&quot;</span>
                    <span class="s">&quot; required if you want to send syslog messages to a remote &quot;</span>
                    <span class="s">&quot;syslog server but for this to work you must set the &quot;</span>
                    <span class="s">&quot;syslog_host variable either via the command-line switch or&quot;</span>
                    <span class="s">&quot; in your server.conf.&quot;</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">syslog_facility</span><span class="p">:</span>
                <span class="n">syslog_facility</span> <span class="o">=</span> <span class="n">syslog</span><span class="o">.</span><span class="n">LOG_DAEMON</span>
            <span class="n">syslog_facility</span> <span class="o">=</span> <span class="n">syslog_facility</span>
            <span class="c"># Sets up syslog messages to show up like this:</span>
            <span class="c">#   Sep 28 19:45:02 &lt;hostname&gt; gateone: &lt;log message&gt;</span>
            <span class="n">syslog</span><span class="o">.</span><span class="n">openlog</span><span class="p">(</span><span class="s">&#39;gateone&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">syslog_facility</span><span class="p">)</span>

<div class="viewcode-block" id="BaseMultiplex.__del__"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.__del__">[docs]</a>    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes sure that the underlying terminal program is terminated so we</span>
<span class="sd">        don&#39;t leave things hanging around.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Calling Multiplex.__del__()&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.__repr__"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns self.__str__()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.__str__"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation of this Multiplex instance and the</span>
<span class="sd">        current state of things.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">started</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">started</span>
        <span class="k">if</span> <span class="n">started</span> <span class="o">!=</span> <span class="s">&quot;Never&quot;</span><span class="p">:</span>
            <span class="n">started</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">started</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s">&quot;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">:  &quot;</span>
            <span class="s">&quot;alive: </span><span class="si">%s</span><span class="s">, &quot;</span>
            <span class="s">&quot;command: </span><span class="si">%s</span><span class="s">, &quot;</span>
            <span class="s">&quot;started: </span><span class="si">%s</span><span class="s">&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="p">,</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmd</span><span class="p">),</span>
                <span class="n">started</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.add_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.add_callback">[docs]</a>    <span class="k">def</span> <span class="nf">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attaches the given *callback* to the given *event*.  If given,</span>
<span class="sd">        *identifier* can be used to reference this callback leter (e.g. when you</span>
<span class="sd">        want to remove it).  Otherwise an identifier will be generated</span>
<span class="sd">        automatically.  If the given *identifier* is already attached to a</span>
<span class="sd">        callback at the given event, that callback will be replaced with</span>
<span class="sd">        *callback*.</span>

<span class="sd">        *event* - The numeric ID of the event you&#39;re attaching *callback* to (e.g. Multiplex.CALLBACK_UPDATE).</span>
<span class="sd">        *callback* - The function you&#39;re attaching to the *event*.</span>
<span class="sd">        *identifier* - A string or number to be used as a reference point should you wish to remove or update this callback later.</span>

<span class="sd">        Returns the identifier of the callback.  to Example:</span>

<span class="sd">            &gt;&gt;&gt; m = Multiplex()</span>
<span class="sd">            &gt;&gt;&gt; def somefunc(): pass</span>
<span class="sd">            &gt;&gt;&gt; id = &quot;myref&quot;</span>
<span class="sd">            &gt;&gt;&gt; ref = m.add_callback(m.CALLBACK_UPDATE, somefunc, id)</span>

<span class="sd">        .. note:: This allows the controlling program to have multiple callbacks for the same event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">identifier</span><span class="p">:</span>
            <span class="n">identifier</span> <span class="o">=</span> <span class="n">callback</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">event</span><span class="p">][</span><span class="n">identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="k">return</span> <span class="n">identifier</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.remove_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.remove_callback">[docs]</a>    <span class="k">def</span> <span class="nf">remove_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the callback referenced by *identifier* that is attached to the</span>
<span class="sd">        given *event*.  Example:</span>

<span class="sd">            &gt;&gt;&gt; m.remove_callback(m.CALLBACK_BELL, &quot;myref&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">event</span><span class="p">][</span><span class="n">identifier</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c"># Doesn&#39;t exist anymore--nothing to do</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.remove_all_callbacks"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.remove_all_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">remove_all_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all callbacks associated with *identifier*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">identifiers</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">event</span><span class="p">][</span><span class="n">identifier</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c"># Doesn&#39;t exist--nothing to worry about</span>
</div>
<div class="viewcode-block" id="BaseMultiplex._call_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex._call_callback">[docs]</a>    <span class="k">def</span> <span class="nf">_call_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is here in the event that subclasses of BaseMultiplex need</span>
<span class="sd">        to call callbacks in an implementation-specific way.  It just calls</span>
<span class="sd">        *callback*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.spawn"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.spawn">[docs]</a>    <span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;spawn() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.isalive"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.isalive">[docs]</a>    <span class="k">def</span> <span class="nf">isalive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;isalive() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.term_write"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.term_write">[docs]</a>    <span class="k">def</span> <span class="nf">term_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes :py:obj:`stream` to :py:data:`term` and also takes care of</span>
<span class="sd">        logging to :py:attr:`log_path` (if set) and/or syslog (if</span>
<span class="sd">        :py:attr:`syslog` is `True`).  When complete, will call any</span>
<span class="sd">        callbacks registered in :py:obj:`CALLBACK_UPDATE`.</span>

<span class="sd">            :stream: A string or bytes containing the incoming output stream from the underlying terminal program.</span>

<span class="sd">        .. note:: This kind of logging doesn&#39;t capture user keystrokes.  This is intentional as we don&#39;t want passwords winding up in the logs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Write to the log (if configured)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">:</span>
            <span class="n">now</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">):</span>
                <span class="c"># Write the first frame as metadata</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s">&#39;version&#39;</span><span class="p">:</span> <span class="s">&#39;1.0&#39;</span><span class="p">,</span> <span class="c"># Log format version</span>
                    <span class="s">&#39;rows&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span>
                    <span class="s">&#39;cols&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                    <span class="s">&#39;start_date&#39;</span><span class="p">:</span> <span class="n">now</span>
                    <span class="c"># NOTE: end_date should be added later when the is read for</span>
                    <span class="c"># the first time by either the logviewer or the logging</span>
                    <span class="c"># plugin.</span>
                <span class="p">}</span>
                <span class="c"># The hope is that we can use the first-frame-metadata paradigm</span>
                <span class="c"># to store all sorts of useful information about a log.</span>
                <span class="n">output</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">json_encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">))</span>
                <span class="n">output</span> <span class="o">=</span> <span class="s">u&quot;</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="se">\U000f0f0f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
                <span class="n">log</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;utf-8&quot;</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c"># NOTE: I&#39;m using an obscure unicode symbol in order to avoid</span>
            <span class="c"># conflicts.  We need to dpo our best to ensure that we can</span>
            <span class="c"># differentiate between terminal output and our log format...</span>
            <span class="c"># This should do the trick because it is highly unlikely that</span>
            <span class="c"># someone would be displaying this obscure unicode symbol on an</span>
            <span class="c"># actual terminal unless they were using Gate One to view a</span>
            <span class="c"># Gate One log file in vim or something =)</span>
            <span class="c"># \U000f0f0f == U+F0F0F (Private Use Symbol)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">,</span> <span class="s">&quot;ignore&quot;</span><span class="p">))</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s">u&quot;</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="se">\U000f0f0f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
            <span class="n">log</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;utf-8&quot;</span><span class="p">))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c"># NOTE: Gate One&#39;s log format is special in that it can be used for both</span>
        <span class="c"># playing back recorded sessions *or* generating syslog-like output.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog</span><span class="p">:</span>
            <span class="c"># Try and keep it as line-line as possible so we don&#39;t end up with</span>
            <span class="c"># a log line per character.</span>
            <span class="k">if</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">+</span> <span class="n">line</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                    <span class="c"># Sylog really doesn&#39;t like any fancy encodings</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">,</span> <span class="s">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
                    <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_id</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">+=</span> <span class="n">stream</span>
        <span class="c"># Handle preprocess patterns (for expect())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="c"># Handle post-process patterns (for expect())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postprocess</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.preprocess"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles preprocess patterns registered by :py:meth:`expect`.  That</span>
<span class="sd">        is, those patterns which have been marked with `preprocess = True`.</span>
<span class="sd">        Patterns marked in this way get handled *before* the terminal emulator</span>
<span class="sd">        processes the :py:obj:`stream`.</span>

<span class="sd">            :stream: A string or bytes containing the incoming output stream from the underlying terminal program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preprocess_patterns</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">preprocess</span><span class="p">)</span>
        <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># If there aren&#39;t any preprocess patterns this won&#39;t do anything:</span>
        <span class="k">for</span> <span class="n">pattern_obj</span> <span class="ow">in</span> <span class="n">preprocess_patterns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">finished_non_sticky</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                <span class="c"># We only want sticky patterns if we&#39;ve already matched once</span>
                <span class="k">continue</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">))</span> <span class="c"># Remove it</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">optional</span><span class="p">:</span>
                    <span class="c"># We only match the first non-optional pattern</span>
                    <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c"># TODO: Figure out why we&#39;re not catching our ready_string</span></div>
<div class="viewcode-block" id="BaseMultiplex.postprocess"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.postprocess">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles post-process patterns registered by :py:meth:`expect`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check the terminal emulator screen for any matching patterns.</span>
        <span class="n">post_patterns</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">preprocess</span><span class="p">)</span>
        <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">pattern_obj</span> <span class="ow">in</span> <span class="n">post_patterns</span><span class="p">:</span>
            <span class="c"># For post-processing matches we search the terminal emulator&#39;s</span>
            <span class="c"># screen as a single string.  This allows for full-screen screen</span>
            <span class="c"># scraping in addition to typical &#39;expect-like&#39; functionality.</span>
            <span class="c"># The big difference being that with traditional expect (and</span>
            <span class="c"># pexpect) you don&#39;t get to examine the program&#39;s output as it</span>
            <span class="c"># would be rendered in an actual terminal.</span>
            <span class="c"># By using post-processing of the text after it has been handled</span>
            <span class="c"># by a terminal emulator we don&#39;t have to worry about hidden</span>
            <span class="c"># characters and escape sequences that we may not be aware of or</span>
            <span class="c"># could make our regular expressions much more complicated than</span>
            <span class="c"># they should be.</span>
            <span class="k">if</span> <span class="n">finished_non_sticky</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c"># We only want sticky patterns at this point</span>
            <span class="c"># For convenience, trailing whitespace is removed from the lines</span>
            <span class="c"># output from the terminal emulator.  This is so we don&#39;t have to</span>
            <span class="c"># put &#39;\w*&#39; before every &#39;$&#39; to match the end of a line.</span>
            <span class="n">term_lines</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">dump</span><span class="p">()])</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">term_lines</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_handle_match</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">term_lines</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_handle_match</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex._handle_match"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex._handle_match">[docs]</a>    <span class="k">def</span> <span class="nf">_handle_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern_obj</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles a matched regex detected by :py:meth:`postprocess`.  It calls the :py:obj:`Pattern.callback` and takes care of removing it from :py:attr:`_patterns` (if it isn&#39;t sticky).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">debug_callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">debug_expect</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">debug_callback</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">))</span> <span class="c"># Remove it</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">optional</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
            <span class="c"># We only match the first non-optional pattern</span>
            <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.writeline"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.writeline">[docs]</a>    <span class="k">def</span> <span class="nf">writeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just like Multiplex.write() but it writes a newline after writing</span>
<span class="sd">        *line*.</span>

<span class="sd">        If no *line* is given a newline will be written.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">u&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.writelines"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.writelines">[docs]</a>    <span class="k">def</span> <span class="nf">writelines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes *lines* (a list of strings) to the underlying program, appending</span>
<span class="sd">        a newline after each line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">u&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not iterable (strings don&#39;t count :)&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">lines</span><span class="p">)))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.dump_html"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.dump_html">[docs]</a>    <span class="k">def</span> <span class="nf">dump_html</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">client_id</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the difference of terminal lines (a list of lines, to be</span>
<span class="sd">        specific) and its scrollback buffer (which is also a list of lines) as a</span>
<span class="sd">        tuple, (scrollback, text).  If a line hasn&#39;t changed since the last dump</span>
<span class="sd">        said line will be replaced with an empty string in the output.</span>

<span class="sd">        If *full*, will return the entire screen (not just the diff).</span>
<span class="sd">        if *client_id* is given (string), this will be used as a unique client</span>
<span class="sd">        identifier for keeping track of screen differences (so you can have</span>
<span class="sd">        multiple clients getting their own unique diff output for the same</span>
<span class="sd">        Multiplex instance).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">client_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="p">[</span><span class="n">client_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">scrollback</span><span class="p">,</span> <span class="n">html</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">dump_html</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">scrollback</span><span class="p">,</span> <span class="n">html</span> <span class="o">=</span> <span class="n">result</span>
                        <span class="c"># Make a copy so we can save it to prev_output later</span>
                        <span class="n">preserved_html</span> <span class="o">=</span> <span class="n">html</span><span class="p">[:]</span>
                <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;IOError attempting self.term.dump_html()&quot;</span><span class="p">))</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">html</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">full</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">line1</span><span class="p">,</span> <span class="n">line2</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="p">[</span><span class="n">client_id</span><span class="p">],</span> <span class="n">html</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">line1</span> <span class="o">!=</span> <span class="n">line2</span><span class="p">:</span>
                            <span class="n">html</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">line2</span> <span class="c"># I love updates-in-place</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">html</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c"># Otherwise a full dump will take place</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">client_id</span><span class="p">:</span> <span class="n">preserved_html</span><span class="p">})</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">scrollback</span><span class="p">,</span> <span class="n">html</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># This would be special...</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;ValueError in dumplines(): </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;Unhandled exception in dumplines(): </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span><span class="p">:</span>
                <span class="c"># Caused by the program being out of control</span>
                <span class="k">return</span><span class="p">([],</span> <span class="p">[</span>
                    <span class="n">_</span><span class="p">(</span><span class="s">&quot;&lt;b&gt;Program output too noisy.  Sending Ctrl-c...&lt;/b&gt;&quot;</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">traceback</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">([],</span> <span class="p">[])</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.dump"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dumps whatever is currently on the screen of the terminal emulator as</span>
<span class="sd">        a list of plain strings (so they&#39;ll be escaped and look nice in an</span>
<span class="sd">        interactive Python interpreter).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.timeout_check"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.timeout_check">[docs]</a>    <span class="k">def</span> <span class="nf">timeout_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout_now</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over :py:attr:`_patterns` checking each to determine if it has</span>
<span class="sd">        timed out.  If a timeout has occurred for a Pattern and said Pattern has</span>
<span class="sd">        an *errorback* function that function will be called.</span>

<span class="sd">        Returns True if there are still non-sticky patterns remaining.  False</span>
<span class="sd">        otherwise.</span>

<span class="sd">        If *timeout_now* is True, will force the first errorback to be called</span>
<span class="sd">        and will empty out self._patterns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">pattern_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">timeout_now</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">:</span>
                    <span class="n">errorback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">errorback</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="n">elapsed</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">created</span>
            <span class="k">if</span> <span class="n">elapsed</span> <span class="o">&gt;</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">timeout</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">:</span>
                    <span class="n">errorback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">errorback</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">remaining_patterns</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.expect"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.expect">[docs]</a>    <span class="k">def</span> <span class="nf">expect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">sticky</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">errorback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
            <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">preprocess</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Watches the stream of output coming from the underlying terminal program</span>
<span class="sd">        for *patterns* and if there&#39;s a match *callback* will be called::</span>

<span class="sd">            callback(multiplex_instance, matched_string)</span>

<span class="sd">        *patterns* can be a string, an :py:obj:`re.SRE_Pattern` (as created by</span>
<span class="sd">        :py:func:`re.compile`), or a iterator of either/or.  Returns a reference</span>
<span class="sd">        object that can be used to remove the registered pattern/callback at any</span>
<span class="sd">        time using the :py:meth:`unexpect` method (see below).</span>

<span class="sd">        .. note::  This function is non-blocking!</span>

<span class="sd">        .. warning::  The *timeout* value gets compared against the time :py:meth:`expect` was called to create it.  So don&#39;t wait too long if you&#39;re planning on using :py:meth:`await`!</span>

<span class="sd">        Here&#39;s a simple example that changes a user&#39;s password::</span>

<span class="sd">            &gt;&gt;&gt; def write_password(m_instance, matched):</span>
<span class="sd">            ...     print(&quot;Sending Password... %s patterns remaining.&quot; % len(m_instance._patterns))</span>
<span class="sd">            ...     m_instance.writeline(&#39;somepassword&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;passwd someuser&#39;) # Assumes running as root :)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;(?i)password:&#39;, write_password) # Step 1</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;(?i)password:&#39;, write_password) # Step 2</span>
<span class="sd">            &gt;&gt;&gt; print(len(m._patterns)) # To show that there&#39;s two in the queue</span>
<span class="sd">                2</span>
<span class="sd">            &gt;&gt;&gt; m.spawn() # Execute the command</span>
<span class="sd">            &gt;&gt;&gt; m.await(10) # This will block for up to 10 seconds waiting for self._patterns to be empty (not counting optional patterns)</span>
<span class="sd">            Sending Password... 1 patterns remaining.</span>
<span class="sd">            Sending Password... 0 patterns remaining.</span>
<span class="sd">            &gt;&gt;&gt; m.isalive()</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; # All done!</span>

<span class="sd">        .. tip:: The :py:meth:`await` method will automatically call :py:meth:`spawn` if not :py:meth:`isalive`.</span>

<span class="sd">        This would result in the password of &#39;someuser&#39; being changed to &#39;somepassword&#39;.  How is the order determined?  Every time :py:meth:`expect` is called it creates a new :py:class:`Pattern` using the given parameters and appends it to :py:attr:`_patterns` (which is a list).  As each :py:class:`Pattern` is matched its *callback* gets called and the :py:class:`Pattern` is removed from :py:attr:`_patterns` (unless *sticky* is set to True).  So even though the patterns and callbacks listed above were identical they will get executed and removed in the order they were created as each respective :py:class:`Pattern` is matched.</span>

<span class="sd">        .. note:: Only the first pattern or patterns marked as *sticky* are checked against the incoming stream.  If the first non-sticky pattern is marked *optional* then the proceeding pattern will be checked (and so on).  All other patterns will sit in self._patterns until their predecessors are matched/removed.</span>

<span class="sd">        Patterns can be removed from self._patterns as needed by calling</span>
<span class="sd">        unexpect(&lt;reference&gt;).  Here&#39;s an example::</span>

<span class="sd">            &gt;&gt;&gt; def handle_accepting_ssh_key(m_instance, matched):</span>
<span class="sd">            ...     m_instance.writeline(u&#39;yes&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;ssh someuser@somehost&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ref1 = m.expect(&#39;(?i)Are you sure.*\(yes/no\)\?&#39;, handle_accepting_ssh_key, optional=True)</span>
<span class="sd">            &gt;&gt;&gt; def send_password(m_instance, matched):</span>
<span class="sd">            ...    m_instance.unexpect(ref1)</span>
<span class="sd">            ...    self.writeline(&#39;somepassword&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ref2 = m.expect(&#39;(?i)password:&#39;, send_password)</span>
<span class="sd">            &gt;&gt;&gt; # spawn() and/or await() and do stuff...</span>

<span class="sd">        The example above would send &#39;yes&#39; if asked by the SSH program to accept</span>
<span class="sd">        the host&#39;s public key (which would result in it being automatically</span>
<span class="sd">        removed from self._patterns).  However, if this condition isn&#39;t met</span>
<span class="sd">        before send_password() is called, send_password() will use the reference</span>
<span class="sd">        object to remove it directly.  This ensures that the pattern won&#39;t be</span>
<span class="sd">        accidentally matched later on in the program&#39;s execution.</span>

<span class="sd">        .. note:: Even if we didn&#39;t match the &quot;Are you sure...&quot; pattern it would still get auto-removed after its timeout was reached.</span>

<span class="sd">        **About pattern ordering:** The position at which the given pattern will</span>
<span class="sd">        be inserted in self._patterns can be specified via the *position*</span>
<span class="sd">        argument.  The default is to simply append which should be appropriate</span>
<span class="sd">        in most cases.</span>

<span class="sd">        **About Timeouts:** The *timeout* value passed to expect() will be used</span>
<span class="sd">        to determine how long to wait before the pattern is removed from</span>
<span class="sd">        self._patterns.  When this occurs, *errorback* will be called with</span>
<span class="sd">        current Multiplex instance as the only argument.  If *errorback* is None</span>
<span class="sd">        (the default) the pattern will simply be discarded with no action taken.</span>

<span class="sd">        .. note:: If *sticky* is True the *timeout* value will be ignored.</span>

<span class="sd">        **Notes about the length of what will be matched:**  The entire terminal</span>
<span class="sd">        &#39;screen&#39; will be searched every time new output is read from the</span>
<span class="sd">        incoming stream.  This means that the number of rows and columns of the</span>
<span class="sd">        terminal determines the size of the search.  So if your pattern needs to</span>
<span class="sd">        look for something inside of 50 lines of text you need to make sure that</span>
<span class="sd">        when you call spawn() you specify at least rows=50.  Example::</span>

<span class="sd">            &gt;&gt;&gt; def handle_long_search(m_instance, matched)</span>
<span class="sd">            ...     do_stuff(matched)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;someCommandWithLotsOfOutput.sh&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # &#39;begin&#39;, at least one non-newline char, 50 newlines, at least one char, then &#39;end&#39;:</span>
<span class="sd">            &gt;&gt;&gt; my_regex = re.compile(&#39;begin.+[\\n]{50}.+end&#39;, re.MULTILINE)</span>
<span class="sd">            &gt;&gt;&gt; ref = m.expect(my_regex, handle_accepting_ssh_key)</span>
<span class="sd">            &gt;&gt;&gt; m.spawn(rows=51, cols=150)</span>
<span class="sd">            &gt;&gt;&gt; # Call m.read(), m.spawn() or just let an event loop (e.g. Tornado&#39;s IOLoop) take care of things...</span>

<span class="sd">        **About non-printable characters:** If the *postprocess* argument is</span>
<span class="sd">        True (default), patterns will be checked against the current screen as</span>
<span class="sd">        output by the terminal emulator.  This means that things like control</span>
<span class="sd">        codes and escape sequences will be handled and discarded by the terminal</span>
<span class="sd">        emulator and as such won&#39;t be available for patterns to be checked</span>
<span class="sd">        against.  To get around this limitation you can set *preprocess* to True</span>
<span class="sd">        and the pattern will be checked against the incoming stream before it is</span>
<span class="sd">        processed by the terminal emulator.  Example::</span>

<span class="sd">            &gt;&gt;&gt; def handle_xterm_title(m_instance, matched)</span>
<span class="sd">            ...     print(&quot;Caught title: %s&quot; % matched)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;echo -e &quot;\\033]0;Some Title\\007&quot;&#39;)</span>
<span class="sd">            &gt;&gt;&gt; title_seq_regex = re.compile(r&#39;\\x1b\\][0-2]\;(.*?)(\\x07|\\x1b\\\\)&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(title_seq_regex, handle_xterm_title, preprocess=True)</span>
<span class="sd">            &gt;&gt;&gt; m.await()</span>
<span class="sd">            Caught title: Some Title</span>
<span class="sd">            &gt;&gt;&gt;</span>

<span class="sd">        **Notes about debugging:** Instead of using await() to wait for all of your patterns to be matched at once you can make individual calls to read() to determine if your patterns are being matched in the way that you want.  For example::</span>

<span class="sd">            &gt;&gt;&gt; def do_stuff(m_instance, matched):</span>
<span class="sd">            ...     print(&quot;Debug: do_stuff() got %s&quot; % repr(matched))</span>
<span class="sd">            ...     # Do stuff here</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;someLongComplicatedOutput.sh&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some pattern&#39;, do_stuff)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some other pattern&#39;, do_stuff)</span>
<span class="sd">            &gt;&gt;&gt; m.spawn()</span>
<span class="sd">            &gt;&gt;&gt; # Instead of calling await() just call one read() at a time...</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read()))</span>
<span class="sd">            &#39;&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read())) # Oops, called read() too soon.  Try again:</span>
<span class="sd">            &#39;some other pattern&#39;</span>
<span class="sd">            &gt;&gt;&gt; # Doh!  Looks like &#39;some other pattern&#39; comes first.  Let&#39;s start over...</span>
<span class="sd">            &gt;&gt;&gt; m.unexpect() # Called with no arguments, it empties m._patterns</span>
<span class="sd">            &gt;&gt;&gt; m.terminate() # Tip: This will call unexpect() too so the line above really isn&#39;t necessary</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some other pattern&#39;, do_stuff) # This time this one will be first</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some pattern&#39;, do_stuff)</span>
<span class="sd">            &gt;&gt;&gt; m.spawn()</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read())) # This time I watied a moment :)</span>
<span class="sd">            &#39;Debug: do_stuff() got &quot;some other pattern&quot;&#39;</span>
<span class="sd">            &#39;some other pattern&#39;</span>
<span class="sd">            &gt;&gt;&gt; # Huzzah!  Now let&#39;s see if &#39;some pattern&#39; matches...</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read()))</span>
<span class="sd">            &#39;Debug: do_stuff() got &quot;some pattern&quot;&#39;</span>
<span class="sd">            &#39;some pattern&#39;</span>
<span class="sd">            &gt;&gt;&gt; # As you can see, calling read() at-will in an interactive interpreter can be very handy.</span>

<span class="sd">        **About asynchronous use:**  This mechanism is non-blocking (with the exception of await()) and is meant to be used asynchronously.  This means that if the running program has no output, m.read() won&#39;t result in any patterns being matched.  So you must be careful about timing *or* you need to ensure that read() gets called either automatically when there&#39;s data to be read (IOLoop, EPoll, select, etc) or at regular intervals via a loop.  Also, if you&#39;re not calling read() at an interval (i.e. you&#39;re using a mechanism to detect when there&#39;s output to be read before calling it e.g. IOLoop) you need to ensure that timeout_check() is called regularly anyway or timeouts won&#39;t get detected if there&#39;s no output from the underlying program.  See the MultiplexPOSIXIOLoop.read() override for an example of what this means and how to do it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create the Pattern object before we do anything else</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">)):</span>
            <span class="c"># Convert to a compiled regex (assume MULTILINE for the sanity of</span>
            <span class="c"># the ignorant)</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c"># Ensure that all patterns are RegexObjects</span>
            <span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                    <span class="n">pattern_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pattern_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pattern_list</span><span class="p">)</span> <span class="c"># No reason to keep it as a list</span>
        <span class="c"># Convert timeout to a timedelta if necessary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                <span class="s">&quot;The timeout value must be a string, integer, float, or a &quot;</span>
                <span class="s">&quot;timedelta object&quot;</span><span class="p">))</span>
        <span class="n">pattern_obj</span> <span class="o">=</span> <span class="n">Pattern</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="n">optional</span><span class="p">,</span>
            <span class="n">sticky</span><span class="o">=</span><span class="n">sticky</span><span class="p">,</span>
            <span class="n">errorback</span><span class="o">=</span><span class="n">errorback</span><span class="p">,</span>
            <span class="n">preprocess</span><span class="o">=</span><span class="n">preprocess</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">position</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">pattern_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.unexpect"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.unexpect">[docs]</a>    <span class="k">def</span> <span class="nf">unexpect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes *ref* from self._patterns so it will no longer be checked</span>
<span class="sd">        against the incoming stream.  If *ref* is None (the default),</span>
<span class="sd">        self._patterns will be emptied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ref</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># Reset</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hash</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="n">ref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.await"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.await">[docs]</a>    <span class="k">def</span> <span class="nf">await</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Blocks until all non-optional patterns inside self._patterns have been</span>
<span class="sd">        removed *or* if the given *timeout* is reached.  *timeout* may be an</span>
<span class="sd">        integer (in seconds) or a datetime.timedelta object.</span>

<span class="sd">        Returns True if all non-optional, non-sticky patterns were handled</span>
<span class="sd">        successfully.</span>

<span class="sd">        .. warning:: The timeouts attached to Patterns are set when they are created.  Not when when you call :py:meth:`await`!</span>

<span class="sd">        As a convenience, if :py:meth:`isalive` resolves to False,</span>
<span class="sd">        :py:meth:`spawn` will be called automatically with *rows*, *cols*,</span>
<span class="sd">        and *env* given as arguments.</span>

<span class="sd">        await</span>
<span class="sd">            To wait with expectation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="c"># Convert timeout to a timedelta if necessary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                <span class="s">&quot;The timeout value must be a string, integer, float, or a &quot;</span>
                <span class="s">&quot;timedelta object&quot;</span><span class="p">))</span>
        <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">remaining_patterns</span><span class="p">:</span>
            <span class="c"># First we need to discount optional patterns</span>
            <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="o">.</span><span class="n">optional</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                    <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="c"># Now check if we&#39;ve timed out</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Timeout</span><span class="p">(</span><span class="s">&quot;Lingered longer than </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">timeout</span><span class="o">.</span><span class="n">seconds</span><span class="p">)</span>
            <span class="c"># Lastly we perform a read() to ensure the output is processed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Remember:  read() is non-blocking</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="c"># So we don&#39;t eat up all the CPU</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.terminate"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.terminate">[docs]</a>    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;terminate() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex._read"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex._read">[docs]</a>    <span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function must be overridden by subclasses of</span>
<span class="sd">        :py:class:`BaseMultiplex`.  It is expected that this method read the</span>
<span class="sd">        output from the running terminal program in a non-blocking way, pass the</span>
<span class="sd">        result into :py:meth:`term_write`, and then return the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;_read() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.read"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls :py:meth:`_read` and checks if any timeouts have been reached</span>
<span class="sd">        in :py:attr:`_patterns`.  Returns the result of</span>
<span class="sd">        :py:meth:`_read`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
        <span class="c"># Perform checks for timeouts in self._patterns (used by self.expect())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;write() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop">[docs]</a><span class="k">class</span> <span class="nc">MultiplexPOSIXIOLoop</span><span class="p">(</span><span class="n">BaseMultiplex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Multiplex class takes care of executing a child process and keeping</span>
<span class="sd">    track of its state via a terminal emulator (will use terminal.Terminal by</span>
<span class="sd">    default).  If there&#39;s a started instance of tornado.ioloop, handlers will be</span>
<span class="sd">    added to it that automatically keep the terminal emulator synchronized with</span>
<span class="sd">    the output of the child process.</span>

<span class="sd">    If there&#39;s no IOLoop (or it just isn&#39;t started), terminal applications can</span>
<span class="sd">    be interacted with by calling Multiplex.read() (to write any pending output</span>
<span class="sd">    to the terminal emulator) and Multiplex.write() (which writes directly to</span>
<span class="sd">    stdin of the child).</span>

<span class="sd">    NOTE: Multiplex.read() is non-blocking.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Multiplex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">tornado</span> <span class="kn">import</span> <span class="n">ioloop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminating</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span> <span class="o">=</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span> <span class="c"># Monitors child for activity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">set_blocking_signal_threshold</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_io_handler</span><span class="p">)</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">100</span> <span class="c"># 0.1 seconds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">PeriodicCallback</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_timeout_checker</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">io_loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="p">)</span>

<div class="viewcode-block" id="MultiplexPOSIXIOLoop._call_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._call_callback">[docs]</a>    <span class="k">def</span> <span class="nf">_call_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the IOLoop is started, adds the callback via IOLoop.add_callback() to</span>
<span class="sd">        ensure it gets called at the next IOLoop iteration (which is thread</span>
<span class="sd">        safe).  If the IOLoop isn&#39;t started *callback* will get called</span>
<span class="sd">        immediately and directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">running</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">callback</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._reenable_output"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._reenable_output">[docs]</a>    <span class="k">def</span> <span class="nf">_reenable_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restarts capturing output from the underlying terminal program by</span>
<span class="sd">        disengaging the rate limiter and re-instantiating the terminal emulator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># Empty the output queue.</span>
        <span class="kn">import</span> <span class="nn">termios</span>
        <span class="n">termios</span><span class="o">.</span><span class="n">tcflush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TCOFLUSH</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
                <span class="n">updated</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Clear it out</span>
                <span class="k">del</span> <span class="n">updated</span>
        <span class="c"># Create a new terminal emulator instance to free up any memory that</span>
        <span class="c"># was consumed by the runaway process buffering up too much stuff.</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span><span class="p">(</span><span class="n">rows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">)</span>
        <span class="c"># TODO: Consider restoring the mode/state of the terminal emulator.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)]})</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._blocked_io_handler"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._blocked_io_handler">[docs]</a>    <span class="k">def</span> <span class="nf">_blocked_io_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles the situation where a terminal is blocking IO with too much</span>
<span class="sd">        output.  Normally this gets called automatically by IOLoop&#39;s signal</span>
<span class="sd">        threshold mechanism (IOLoop.set_blocking_signal_threshold()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s">&quot;Noisy process kicked off rate limiter.  Sending Ctrl-c.&quot;</span><span class="p">)</span>
        <span class="c">#os.kill(self.pid, signal.SIGINT) # Doesn&#39;t work right with dtach</span>
        <span class="c"># Sending Ctrl-c via write() seems to work better:</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\x03\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="c"># Just pray it works!</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;# Process was auto-killed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
        <span class="c"># This doesn&#39;t seem to work (would be nice if it did though!):</span>
        <span class="c">#os.write(self.fd, &quot;\x19&quot;) # Ctrl-S to the bad process</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reenable_output</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.spawn"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.spawn">[docs]</a>    <span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new virtual terminal (tty) and executes self.cmd within it.</span>
<span class="sd">        Also attaches _ioloop_read_handler() to the IOLoop so that the terminal</span>
<span class="sd">        emulator will automatically stay in sync with the output of the child</span>
<span class="sd">        process.</span>

<span class="sd">        *cols*</span>
<span class="sd">            The number of columns to emulate on the virtual terminal (width)</span>
<span class="sd">        *rows*</span>
<span class="sd">            The number of rows to emulate (height).</span>
<span class="sd">        *env*</span>
<span class="sd">            A dictionary of environment variables to set when executing self.cmd.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIG_IGN</span><span class="p">)</span> <span class="c"># No zombies allowed</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s">&quot;spawn(rows=</span><span class="si">%s</span><span class="s">, cols=</span><span class="si">%s</span><span class="s">, env=</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">env</span><span class="p">)))</span>
        <span class="kn">import</span> <span class="nn">pty</span>
        <span class="n">pid</span><span class="p">,</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">pty</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># We&#39;re inside the child process</span>
    <span class="c"># Close all file descriptors other than stdin, stdout, and stderr (0, 1, 2)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># This ensures that the child doesn&#39;t get the parent&#39;s FDs</span>
                <span class="n">os</span><span class="o">.</span><span class="n">closerange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">env</span><span class="p">:</span>
                <span class="n">env</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;COLUMNS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;LINES&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;TERM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;xterm&quot;</span> <span class="c"># TODO: This needs to be configurable on-the-fly</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;PATH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;PATH&#39;</span><span class="p">]</span>
            <span class="c"># The sleep statement below ensures we capture all output from the</span>
            <span class="c"># fd before it is closed...  It turns out that IOLoop&#39;s response to</span>
            <span class="c"># changes in the fd is so fast that it can result in the fd being</span>
            <span class="c"># closed the very moment the Python interpreter is reading from it.</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/bin/sh&#39;</span><span class="p">,</span> <span class="s">&#39;-c&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmd</span> <span class="o">+</span> <span class="s">&#39;; sleep .1&#39;</span><span class="p">]</span>
            <span class="n">os</span><span class="o">.</span><span class="n">dup2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># Copy stderr to stdout (equivalent to 2&gt;&amp;1)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">execvpe</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># We&#39;re inside this Python script</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span><span class="p">(</span><span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
            <span class="c"># Tell our IOLoop instance to start watching the child</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span>
                <span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ioloop_read_handler</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c"># Set non-blocking so we don&#39;t wait forever for a read()</span>
            <span class="kn">import</span> <span class="nn">fcntl</span>
            <span class="n">fl</span> <span class="o">=</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_GETFL</span><span class="p">)</span>
            <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span> <span class="n">fl</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span>
            <span class="c"># Set the size of the terminal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ctrl_l</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fd</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.isalive"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.isalive">[docs]</a>    <span class="k">def</span> <span class="nf">isalive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the underlying process to see if it is alive and sets self._alive</span>
<span class="sd">        appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="p">:</span> <span class="c"># Re-check it</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s">&#39;/proc&#39;</span><span class="p">):</span>
                <span class="n">pid_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;/proc&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">pid_dir</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">pid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">continue</span> <span class="c"># Not a PID</span>
                    <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">return</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.resize"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ctrl_l</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resizes the child process&#39;s terminal window to *rows* and *cols* by</span>
<span class="sd">        first sending it a TIOCSWINSZ event and then sending ctrl-l.</span>

<span class="sd">        The sending of ctrl-l can be disabled by setting *ctrl_l* to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Resizing term </span><span class="si">%s</span><span class="s"> to rows: </span><span class="si">%s</span><span class="s">, cols: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_id</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
        <span class="c"># Sometimes the resize doesn&#39;t actually apply (for whatever reason)</span>
        <span class="c"># so to get around this we have to send a different value than the</span>
        <span class="c"># actual value we want then send our actual value.  It&#39;s a bug outside</span>
        <span class="c"># of Gate One that I have no idea how to isolate but this has proven to</span>
        <span class="c"># be an effective workaround.</span>
        <span class="kn">import</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">termios</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;HHHH&quot;</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fcntl</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TIOCSWINSZ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ctrl_l</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">u&#39;</span><span class="se">\x0c</span><span class="s">&#39;</span><span class="p">)</span> <span class="c"># ctrl-l</span>
        <span class="c"># SIGWINCH has been disabled since it can screw things up</span>
        <span class="c">#os.kill(self.pid, signal.SIGWINCH) # Send the resize signal</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.terminate"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.terminate">[docs]</a>    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kill the child process associated with the given file descriptor (fd).</span>

<span class="sd">        NOTE: If dtach is being used this only kills the dtach process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminating</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminating</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="c"># Something else already called it</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;terminate() self.pid: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">(</span><span class="n">timeout_now</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="c"># NOTE: Without this &#39;del&#39; we end up with a memory leak every time</span>
            <span class="c"># a new instance of Multiplex is created.  Apparently the references</span>
            <span class="c"># inside of PeriodicCallback pointing to self prevent proper garbage</span>
            <span class="c"># collection.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
            <span class="c"># This can happen when the fd is removed by the underlying process</span>
            <span class="c"># before the next cycle of the IOLoop.  Not really a problem.</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># TODO: Make this walk the series from SIGINT to SIGKILL</span>
            <span class="c">#os.kill(self.pid, signal.SIGINT)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">)</span>
            <span class="c">#os.kill(self.pid, signal.SIGKILL)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">WNOHANG</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="c"># The process is already dead--great.</span>
            <span class="k">pass</span>
        <span class="c"># Unset our blocked IO handler so there&#39;s no references to self hanging</span>
        <span class="c"># around preventing us from freeing up memory</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">set_blocking_signal_threshold</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c"># Can happen if this instance winds up in a thread</span>
        <span class="c"># Kick off a process that finalizes the log (updates metadata and</span>
        <span class="c"># recompresses everything to save disk space)</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
        <span class="c"># Multiprocessing doesn&#39;t get much simpler than this!</span>
        <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># We&#39;re inside the child process</span>
            <span class="n">os</span><span class="o">.</span><span class="n">setsid</span><span class="p">()</span> <span class="c"># This prevents defunct processes (zombies)</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># We&#39;re inside the sub-child process</span>
                <span class="c"># Have to wait just a moment for the main thread to finish writing:</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">get_or_update_metadata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span> <span class="c"># Whatever, the metadata will get fixed when enumerated</span>
                <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._ioloop_read_handler"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._ioloop_read_handler">[docs]</a>    <span class="k">def</span> <span class="nf">_ioloop_read_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read in the output of the process associated with *fd* and write it to</span>
<span class="sd">        self.term.</span>

<span class="sd">        This method will also keep an eye on the output rate of the underlying</span>
<span class="sd">        terminal application.  If it goes to high (which would gobble up CPU) it</span>
<span class="sd">        will engage a rate limiter.  So if someone thinks it would be funny to</span>
<span class="sd">        run &#39;top&#39; with a refresh rate of 0.01 they&#39;ll really only be getting</span>
<span class="sd">        updates every ~2 seconds (and it won&#39;t bog down the server =).</span>

<span class="sd">        NOTE: This method is not meant to be called directly...  The IOLoop</span>
<span class="sd">        should be the one calling it when it detects an io_loop.READ event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># Child died</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                <span class="s">&quot;Apparently fd </span><span class="si">%s</span><span class="s"> just died (event: </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">event</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_EXIT</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._read"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._read">[docs]</a>    <span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads at most *bytes* from the incoming stream, writes the result to</span>
<span class="sd">        the terminal emulator using self.term_write(), and returns what was</span>
<span class="sd">        read.  If *bytes* is -1 (default) it will read self.fd until there&#39;s no</span>
<span class="sd">        more output.</span>

<span class="sd">        Returns the result of all the reads.</span>

<span class="sd">        NOTE: Non-blocking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">bytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                            <span class="n">updated</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">updated</span><span class="p">:</span>
                                <span class="k">break</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span><span class="p">:</span>
                                <span class="c"># Don&#39;t write if the rate limiter is enaged</span>
                                <span class="k">break</span>
                            <span class="n">result</span> <span class="o">+=</span> <span class="n">updated</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">term_write</span><span class="p">(</span><span class="n">updated</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">term_write</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># IOErrors can happen when self.fd is closed before we finish</span>
            <span class="c"># reading from it.  Not a big deal.</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Got exception in read: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="sb">`e`</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">traceback</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s">&quot;Got unhandled exception in read (???): </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="sb">`e`</span><span class="p">)</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._timeout_checker"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._timeout_checker">[docs]</a>    <span class="k">def</span> <span class="nf">_timeout_checker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs :py:meth:`timeout_check` and if there are no more non-sticky</span>
<span class="sd">        patterns in :py:attr:`_patterns`, stops :py:attr:`scheduler`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining_patterns</span><span class="p">:</span>
            <span class="c"># No reason to keep the PeriodicCallback going</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Stopping self.scheduler&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c"># Now this is a neat trick:  The way IOLoop works with its</span>
                <span class="c"># stack_context thingamabob the scheduler doesn&#39;t actualy end up</span>
                <span class="c"># inside the MultiplexPOSIXIOLoop instance inside of this</span>
                <span class="c"># instance of _timeout_checker() *except* inside the main</span>
                <span class="c"># thread.  It is absolutely wacky but it works and works well :)</span>
                <span class="k">pass</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.read"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an override of BaseMultiplex.read() in order to take advantage of the IOLoop for ensuring expect() patterns timeout properly.</span>

<span class="sd">        Calls :py:meth:`_read` and checks if any timeouts have been reached</span>
<span class="sd">        in :py:attr:`_patterns`.  Returns the result of :py:meth:`_read`.  This</span>
<span class="sd">        is an override of BaseMultiplex.read() that will create a</span>
<span class="sd">        `PeriodicCallback` that executes :py:attr:`timeout_check` at a regular</span>
<span class="sd">        interval.  The `PeriodicCallback` will automatically cancel itself if</span>
<span class="sd">        there are no more non-sticky patterns in :py:attr:`_patterns`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
        <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">remaining_patterns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
            <span class="c"># Start &#39;er up in case we don&#39;t get any more output</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Starting self.scheduler to check for timeouts&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._write"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._write">[docs]</a>    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes *chars* to self.fd (pretty straightforward).  If IOError or</span>
<span class="sd">        OSError exceptions are encountered, will run self.die() and</span>
<span class="sd">        self.terminate().  All other exceptions are logged but no action will</span>
<span class="sd">        be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span>
                <span class="s">&#39;wt&#39;</span><span class="p">,</span>
                <span class="n">newline</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span>
                <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;UTF-8&#39;</span><span class="p">,</span>
                <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;write() exception: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.write"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls self._write(*chars*) via self._call_callback() to ensure thread</span>
<span class="sd">        safety.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">write</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">,</span> <span class="n">chars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">write</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="spawn"><a class="viewcode-back" href="../Developer/termio.html#termio.spawn">[docs]</a><span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A shortcut to::</span>

<span class="sd">        &gt;&gt;&gt; m = Multiplex(cmd, *args, **kwargs)</span>
<span class="sd">        &gt;&gt;&gt; m.spawn(rows, cols, env)</span>
<span class="sd">        &gt;&gt;&gt; return m</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">Multiplex</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span>
</div>
<span class="k">if</span> <span class="n">POSIX</span><span class="p">:</span>
    <span class="n">Multiplex</span> <span class="o">=</span> <span class="n">MultiplexPOSIXIOLoop</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
        <span class="s">&quot;termio currently only works on Unix platforms.&quot;</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/ls_logo_1inch_300dpi.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Gate One Documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Liftoff Software Corporation.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>